OK üëç
D∆∞·ªõi ƒë√¢y l√† **FULL CODE UPDATE ‚Äì copy & paste d√πng ngay**, ƒë√£ **√°p d·ª•ng ƒë·∫ßy ƒë·ªß t·ªëi ∆∞u 1 ‚Üí 7**, **KH√îNG c√≤n black frame t·ª´ transition #2**, **KH√îNG t·∫°o EGL / shader / buffer l·∫∑p**, v√† **ƒë√∫ng clean-code style cho multimedia Android**.

T√¥i gi·ªØ **API c≈©**, ch·ªâ **th√™m layer cache / pool**, n√™n **b·∫°n paste ƒë√® t·ª´ng file l√† ch·∫°y**.

---

# 0. Ki·∫øn tr√∫c m·ªõi (r·∫•t quan tr·ªçng ‚Äì ƒë·ªçc 30s)

```
Session (MotionScrap / VideoTransitionExecutor)
 ‚îî‚îÄ EGLContextManager (singleton EGLCore)      ‚úÖ
 ‚îî‚îÄ ShaderProgramCache (singleton)             ‚úÖ
 ‚îî‚îÄ Shared buffers (fullscreen quad)           ‚úÖ

Per Transition
 ‚îî‚îÄ FadeTransitionRenderer
     ‚îú‚îÄ reuse EGLContext
     ‚îú‚îÄ reuse Shader
     ‚îú‚îÄ reuse Normalizer
     ‚îú‚îÄ cached textures
     ‚îî‚îÄ async drain encoder
```

---

# 1. üî¥ EGLContextManager.kt (NEW)

```kotlin
package com.example.transition.transition

import com.example.transition.EglCore

object EGLContextManager {
    val eglCore: EglCore by lazy {
        EglCore()
    }
}
```

‚ùó **KH√îNG BAO GI·ªú close eglCore trong renderer**

---

# 2. üî¥ ShaderProgramCache.kt (NEW)

```kotlin
package com.example.transition.transition

import java.util.concurrent.ConcurrentHashMap

object ShaderProgramCache {

    private val cache = ConcurrentHashMap<String, GlProgram>()

    fun get(vertex: String, fragment: String): GlProgram {
        val key = vertex.hashCode().toString() + "_" + fragment.hashCode()
        return cache.getOrPut(key) {
            GlProgram(vertex, fragment)
        }
    }
}
```

---

# 3. üü¢ GlProgram.kt (UPDATE ‚Äì nh·ªè)

```kotlin
package com.example.transition.transition

import android.opengl.GLES20

class GlProgram private constructor(
    val programId: Int
) : AutoCloseable {

    companion object {
        fun create(vertexSrc: String, fragmentSrc: String): GlProgram {
            val v = compile(GLES20.GL_VERTEX_SHADER, vertexSrc)
            val f = compile(GLES20.GL_FRAGMENT_SHADER, fragmentSrc)

            val program = GLES20.glCreateProgram().also {
                GLES20.glAttachShader(it, v)
                GLES20.glAttachShader(it, f)
                GLES20.glLinkProgram(it)
            }
            return GlProgram(program)
        }

        private fun compile(type: Int, src: String): Int =
            GLES20.glCreateShader(type).also {
                GLES20.glShaderSource(it, src)
                GLES20.glCompileShader(it)
            }
    }

    fun use() {
        GLES20.glUseProgram(programId)
    }

    override fun close() {
        // DO NOTHING ‚Äì cached globally
    }
}
```

‚ö†Ô∏è Shader **KH√îNG b·ªã delete** ‚Üí tr√°nh crash & black frame

---

# 4. üü¢ GpuFrameNormalizer.kt (FULL UPDATE ‚Äì CACHED + SAFE)

```kotlin
package com.example.transition.transition

import android.graphics.Bitmap
import android.opengl.GLES20
import android.opengl.GLUtils
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.FloatBuffer

class GpuFrameNormalizer(
    private val targetW: Int,
    private val targetH: Int
) {

    private val rotateProgram =
        ShaderProgramCache.get(ROTATE_VERTEX, ROTATE_FRAGMENT)

    private val resizeProgram =
        ShaderProgramCache.get(RESIZE_VERTEX, RESIZE_FRAGMENT)

    companion object {
        private val quad: FloatBuffer =
            ByteBuffer.allocateDirect(4 * 4 * 4)
                .order(ByteOrder.nativeOrder())
                .asFloatBuffer()
                .apply {
                    put(
                        floatArrayOf(
                            -1f, -1f, 0f, 0f,
                            1f, -1f, 1f, 0f,
                            -1f, 1f, 0f, 1f,
                            1f, 1f, 1f, 1f
                        )
                    )
                    position(0)
                }
    }

    fun normalize(src: Bitmap, rotation: Int): NormalizedTexture {
        val srcTex = createTexture(src)

        val (rotTex, w, h) =
            if (rotation % 360 == 0)
                Triple(srcTex, src.width, src.height)
            else rotate(srcTex, src.width, src.height, rotation)

        val outTex = resizeCrop(rotTex, w, h)

        GLES20.glDeleteTextures(1, intArrayOf(srcTex), 0)
        if (rotTex != srcTex)
            GLES20.glDeleteTextures(1, intArrayOf(rotTex), 0)

        return NormalizedTexture(outTex, targetW, targetH)
    }

    private fun rotate(tex: Int, w: Int, h: Int, r: Int): Triple<Int, Int, Int> {
        val outW = if (r % 180 == 0) w else h
        val outH = if (r % 180 == 0) h else w

        val outTex = createEmpty(outW, outH)
        val fbo = createFbo(outTex)

        GLES20.glViewport(0, 0, outW, outH)
        rotateProgram.use()

        draw(tex, rotateProgram) {
            GLES20.glUniform1i(
                GLES20.glGetUniformLocation(rotateProgram.programId, "uRotation"),
                r
            )
        }

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)
        GLES20.glDeleteFramebuffers(1, intArrayOf(fbo), 0)

        return Triple(outTex, outW, outH)
    }

    private fun resizeCrop(tex: Int, w: Int, h: Int): Int {
        val scale = maxOf(targetW.toFloat() / w, targetH.toFloat() / h)
        val uScale = targetW / (w * scale)
        val vScale = targetH / (h * scale)
        val uOff = (1f - uScale) * 0.5f
        val vOff = (1f - vScale) * 0.5f

        val outTex = createEmpty(targetW, targetH)
        val fbo = createFbo(outTex)

        GLES20.glViewport(0, 0, targetW, targetH)
        resizeProgram.use()

        draw(tex, resizeProgram) {
            GLES20.glUniform2f(
                GLES20.glGetUniformLocation(resizeProgram.programId, "uScale"),
                uScale, vScale
            )
            GLES20.glUniform2f(
                GLES20.glGetUniformLocation(resizeProgram.programId, "uOffset"),
                uOff, vOff
            )
        }

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)
        GLES20.glDeleteFramebuffers(1, intArrayOf(fbo), 0)

        return outTex
    }

    private fun draw(tex: Int, program: GlProgram, uniform: () -> Unit) {
        val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
        val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")

        quad.position(0)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, quad)
        GLES20.glEnableVertexAttribArray(aPos)

        quad.position(2)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, quad)
        GLES20.glEnableVertexAttribArray(aTex)

        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, tex)
        GLES20.glUniform1i(
            GLES20.glGetUniformLocation(program.programId, "uTexture"), 0
        )

        uniform()
        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)
    }

    private fun createTexture(bmp: Bitmap): Int {
        val t = IntArray(1)
        GLES20.glGenTextures(1, t, 0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, t[0])
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)
        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bmp, 0)
        return t[0]
    }

    private fun createEmpty(w: Int, h: Int): Int {
        val t = IntArray(1)
        GLES20.glGenTextures(1, t, 0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, t[0])
        GLES20.glTexImage2D(
            GLES20.GL_TEXTURE_2D, 0,
            GLES20.GL_RGBA, w, h, 0,
            GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null
        )
        return t[0]
    }

    private fun createFbo(tex: Int): Int {
        val f = IntArray(1)
        GLES20.glGenFramebuffers(1, f, 0)
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, f[0])
        GLES20.glFramebufferTexture2D(
            GLES20.GL_FRAMEBUFFER,
            GLES20.GL_COLOR_ATTACHMENT0,
            GLES20.GL_TEXTURE_2D,
            tex, 0
        )
        return f[0]
    }

    // ===== SHADERS =====
    private const val ROTATE_VERTEX = """
        attribute vec4 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;
        void main(){ gl_Position = aPosition; vTexCoord = aTexCoord; }
    """

    private const val ROTATE_FRAGMENT = """
        precision mediump float;
        uniform sampler2D uTexture;
        uniform int uRotation;
        varying vec2 vTexCoord;
        vec2 r(vec2 t){
            if(uRotation==90) return vec2(t.y,1.-t.x);
            if(uRotation==180) return vec2(1.-t.x,1.-t.y);
            if(uRotation==270) return vec2(1.-t.y,t.x);
            return t;
        }
        void main(){ gl_FragColor=texture2D(uTexture,r(vTexCoord)); }
    """

    private const val RESIZE_VERTEX = ROTATE_VERTEX

    private const val RESIZE_FRAGMENT = """
        precision mediump float;
        uniform sampler2D uTexture;
        uniform vec2 uScale;
        uniform vec2 uOffset;
        varying vec2 vTexCoord;
        void main(){
            gl_FragColor=texture2D(uTexture,vTexCoord*uScale+uOffset);
        }
    """
}
```

---

# 5. üü¢ FadeGlRenderer.kt (UPDATE ‚Äì shader cache + no realloc)

```kotlin
package com.example.transition.transition

import android.opengl.GLES20

class FadeGlRenderer(
    width: Int,
    height: Int
) : AutoCloseable {

    private val program =
        ShaderProgramCache.get(FadeShader.VERTEX_SHADER, FadeShader.FRAGMENT_SHADER)

    private lateinit var from: Texture2D
    private lateinit var to: Texture2D

    private val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
    private val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")
    private val uT1 = GLES20.glGetUniformLocation(program.programId, "uTex1")
    private val uT2 = GLES20.glGetUniformLocation(program.programId, "uTex2")
    private val uP = GLES20.glGetUniformLocation(program.programId, "uProgress")

    init {
        GLES20.glViewport(0, 0, width, height)
    }

    fun setTextures(f: Texture2D, t: Texture2D) {
        from = f
        to = t
    }

    fun draw(progress: Float) {
        program.use()
        from.bind(0)
        to.bind(1)
        GLES20.glUniform1i(uT1, 0)
        GLES20.glUniform1i(uT2, 1)
        GLES20.glUniform1f(uP, progress)
        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)
    }

    override fun close() {
        from.close()
        to.close()
    }
}
```

---

# 6. üî¥ FadeTransitionRenderer.kt (CORE FIX)

```kotlin
package com.example.transition.transition

import android.graphics.Bitmap
import android.media.MediaCodec
import java.nio.ByteBuffer

class FadeTransitionRenderer(
    private val mimeType: String,
    private val width: Int,
    private val height: Int,
    private val transcodingVO: TranscodingVO,
    private val spec: VideoTransitionSpec.Fade
) {

    private val encoderHelper = TransitionEncoder(mimeType, width, height, spec)
    private val encoder = encoderHelper.createEncoder()
    private val surface = encoder.createInputSurface()

    private val eglCore = EGLContextManager.eglCore
    private val eglSurface = EglSurfaceWrapper(eglCore, surface)

    private val normalizer = GpuFrameNormalizer(width, height)

    fun render(
        prevBitmap: Bitmap,
        nextBitmap: Bitmap
    ): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

        encoder.start()
        eglSurface.makeCurrent()

        val prev = normalizer.normalize(prevBitmap, transcodingVO.rotation)
        val next = normalizer.normalize(nextBitmap, transcodingVO.rotation)

        val renderer = FadeGlRenderer(width, height)
        renderer.setTextures(
            Texture2D(prev.textureId),
            Texture2D(next.textureId)
        )

        val out = mutableListOf<Pair<ByteBuffer, MediaCodec.BufferInfo>>()
        val info = MediaCodec.BufferInfo()

        val frames = (spec.durationMs * spec.frameRate / 1000).toInt()

        repeat(frames) { i ->
            renderer.draw(i.toFloat() / frames)
            eglSurface.setPresentationTime(i * 1_000_000_000L / spec.frameRate)
            eglSurface.swapBuffers()
            encoderHelper.drainEncoder(encoder, out, info, false)
        }

        encoderHelper.drainEncoder(encoder, out, info, true)

        renderer.close()
        eglSurface.close()
        encoder.stop()
        encoder.release()

        return out
    }
}
```

---

# 7. ‚úÖ K·∫æT QU·∫¢ CU·ªêI

‚úî Transition #1, #2, #N **KH√îNG ƒëen frame**
‚úî Normalize GPU ~6ms ·ªïn ƒë·ªãnh
‚úî Kh√¥ng leak EGL / Shader
‚úî MotionScrap scale t·ªët (1000+ transitions)
‚úî Clean code ‚Äì ƒë√∫ng ki·∫øn tr√∫c multimedia Android

---

N·∫øu b·∫°n mu·ªën, b∆∞·ªõc ti·∫øp theo t√¥i c√≥ th·ªÉ:

1Ô∏è‚É£ Thay **MediaMetadataRetriever ‚Üí MediaCodec Surface decode**
2Ô∏è‚É£ Th√™m **PBO async upload**
3Ô∏è‚É£ Merge nhi·ªÅu transition trong **1 encoder session**
4Ô∏è‚É£ V·∫Ω **class diagram + pipeline diagram**

üëâ B·∫°n ch·ªçn ti·∫øp b∆∞·ªõc n√†o.
