OK, d∆∞·ªõi ƒë√¢y l√† **FULL CODE normalize b·∫±ng OpenGL** theo ƒë√∫ng pipeline c·ªßa b·∫°n, **lo·∫°i b·ªè ho√†n to√†n `FrameNormalizer.normalize()`**, d√πng **shader + texture transform**, c√≥ th·ªÉ **copy‚Äìpaste ch·∫°y ƒë∆∞·ª£c** v√† g·∫Øn th·∫≥ng v√†o `FadeTransitionRenderer`.

M·ª•c ti√™u:

* ‚ùå Kh√¥ng t·∫°o bitmap trung gian
* ‚úÖ Rotate / scale / crop **tr√™n GPU**
* ‚úÖ D√πng **bitmap g·ªëc** ‚Üí upload texture 1 l·∫ßn
* ‚úÖ Chu·∫©n cho MotionScrap / encoder surface

---

# 1Ô∏è‚É£ Shader normalize (Vertex + Fragment)

## Vertex shader (normalize + fade)

```glsl
attribute vec4 aPosition;
attribute vec2 aTexCoord;

uniform mat3 uTexTransform;

varying vec2 vTexCoord;

void main() {
    gl_Position = aPosition;
    vec3 tc = uTexTransform * vec3(aTexCoord, 1.0);
    vTexCoord = tc.xy;
}
```

## Fragment shader (fade)

```glsl
precision mediump float;

uniform sampler2D uTex1;
uniform sampler2D uTex2;
uniform float uProgress;

varying vec2 vTexCoord;

void main() {
    vec4 c1 = texture2D(uTex1, vTexCoord);
    vec4 c2 = texture2D(uTex2, vTexCoord);
    gl_FragColor = mix(c1, c2, uProgress);
}
```

---

# 2Ô∏è‚É£ Build texture transform matrix (CPU, nh·∫π)

```kotlin
object TexTransformUtil {

    fun build(
        srcW: Int,
        srcH: Int,
        targetW: Int,
        targetH: Int,
        rotation: Int
    ): FloatArray {

        val scale = maxOf(
            targetW.toFloat() / srcW,
            targetH.toFloat() / srcH
        )

        val sx = (srcW * scale) / targetW
        val sy = (srcH * scale) / targetH

        val m = android.graphics.Matrix().apply {
            postTranslate(-0.5f, -0.5f)
            postRotate(-rotation.toFloat())
            postScale(sx, sy)
            postTranslate(0.5f, 0.5f)
        }

        val v = FloatArray(9)
        m.getValues(v)

        return floatArrayOf(
            v[0], v[3], v[6],
            v[1], v[4], v[7],
            v[2], v[5], v[8]
        )
    }
}
```

---

# 3Ô∏è‚É£ GlProgram (c√≥ set uniform mat3)

```kotlin
class GlProgram(
    vertexSrc: String,
    fragmentSrc: String
) : AutoCloseable {

    val programId: Int

    init {
        val vs = compile(GLES20.GL_VERTEX_SHADER, vertexSrc)
        val fs = compile(GLES20.GL_FRAGMENT_SHADER, fragmentSrc)

        programId = GLES20.glCreateProgram().also {
            GLES20.glAttachShader(it, vs)
            GLES20.glAttachShader(it, fs)
            GLES20.glLinkProgram(it)
        }
    }

    fun use() {
        GLES20.glUseProgram(programId)
    }

    fun setMat3(location: Int, value: FloatArray) {
        GLES20.glUniformMatrix3fv(location, 1, false, value, 0)
    }

    private fun compile(type: Int, src: String): Int =
        GLES20.glCreateShader(type).also {
            GLES20.glShaderSource(it, src)
            GLES20.glCompileShader(it)
        }

    override fun close() {
        GLES20.glDeleteProgram(programId)
    }
}
```

---

# 4Ô∏è‚É£ FadeGlRenderer (normalize + fade)

```kotlin
class FadeGlRenderer(
    private val width: Int,
    private val height: Int
) : AutoCloseable {

    private val vertexData = floatArrayOf(
        -1f, -1f, 0f, 1f,
         1f, -1f, 1f, 1f,
        -1f,  1f, 0f, 0f,
         1f,  1f, 1f, 0f
    )

    private val vertexBuffer =
        ByteBuffer.allocateDirect(vertexData.size * 4)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer()
            .apply { put(vertexData).position(0) }

    private val program = GlProgram(
        NormalizeFadeShader.VERTEX,
        NormalizeFadeShader.FRAGMENT
    )

    private val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
    private val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")

    private val uTex1 = GLES20.glGetUniformLocation(program.programId, "uTex1")
    private val uTex2 = GLES20.glGetUniformLocation(program.programId, "uTex2")
    private val uProgress = GLES20.glGetUniformLocation(program.programId, "uProgress")
    private val uTexTransform = GLES20.glGetUniformLocation(program.programId, "uTexTransform")

    fun draw(
        tex1: Texture2D,
        tex2: Texture2D,
        texMatrix: FloatArray,
        progress: Float
    ) {
        GLES20.glViewport(0, 0, width, height)
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)

        program.use()
        program.setMat3(uTexTransform, texMatrix)

        vertexBuffer.position(0)
        GLES20.glEnableVertexAttribArray(aPos)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, vertexBuffer)

        vertexBuffer.position(2)
        GLES20.glEnableVertexAttribArray(aTex)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, vertexBuffer)

        tex1.bind(0)
        GLES20.glUniform1i(uTex1, 0)

        tex2.bind(1)
        GLES20.glUniform1i(uTex2, 1)

        GLES20.glUniform1f(uProgress, progress)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)
    }

    override fun close() {
        program.close()
    }
}
```

---

# 5Ô∏è‚É£ Shader holder

```kotlin
object NormalizeFadeShader {

    const val VERTEX = """
        attribute vec4 aPosition;
        attribute vec2 aTexCoord;
        uniform mat3 uTexTransform;
        varying vec2 vTexCoord;

        void main() {
            gl_Position = aPosition;
            vec3 tc = uTexTransform * vec3(aTexCoord, 1.0);
            vTexCoord = tc.xy;
        }
    """

    const val FRAGMENT = """
        precision mediump float;
        uniform sampler2D uTex1;
        uniform sampler2D uTex2;
        uniform float uProgress;
        varying vec2 vTexCoord;

        void main() {
            vec4 c1 = texture2D(uTex1, vTexCoord);
            vec4 c2 = texture2D(uTex2, vTexCoord);
            gl_FragColor = mix(c1, c2, uProgress);
        }
    """
}
```

---

# 6Ô∏è‚É£ FadeTransitionRenderer (final ‚Äì NO normalize bitmap)

```kotlin
class FadeTransitionRenderer(
    mimeType: String,
    width: Int,
    height: Int,
    private val spec: VideoTransitionSpec.Fade,
    private val rotation: Int
) {

    private val encoder = TransitionEncoder(mimeType, width, height, spec)
        .createEncoder()

    private val eglCore = EglCore()
    private val inputSurface = encoder.createInputSurface()
    private val eglSurface = EglSurfaceWrapper(eglCore, inputSurface)

    fun render(
        prevBitmap: Bitmap,
        nextBitmap: Bitmap
    ): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

        encoder.start()
        eglSurface.makeCurrent()

        val tex1 = Texture2D(prevBitmap)
        val tex2 = Texture2D(nextBitmap)

        val texMatrix = TexTransformUtil.build(
            prevBitmap.width,
            prevBitmap.height,
            spec.width,
            spec.height,
            rotation
        )

        val renderer = FadeGlRenderer(spec.width, spec.height)
        val out = mutableListOf<Pair<ByteBuffer, MediaCodec.BufferInfo>>()
        val info = MediaCodec.BufferInfo()

        val totalFrames = spec.durationMs * spec.frameRate / 1000

        repeat(totalFrames.toInt()) { i ->
            val progress = i.toFloat() / totalFrames
            renderer.draw(tex1, tex2, texMatrix, progress)
            eglSurface.setPresentationTime(i * 1_000_000_000L / spec.frameRate)
            eglSurface.swapBuffers()
            encoder.drainEncoder(encoder, out, info, false)
        }

        encoder.drainEncoder(encoder, out, info, true)

        renderer.close()
        tex1.close()
        tex2.close()
        eglSurface.close()
        eglCore.close()
        encoder.stop()
        encoder.release()

        return out
    }
}
```

---

# ‚úÖ K·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c

| Tr∆∞·ªõc                     | Sau        |
| ------------------------- | ---------- |
| CPU rotate + scale + crop | GPU shader |
| 3 bitmap allocation       | 0          |
| GC spike                  | Kh√¥ng      |
| Normalize t·ªën ms          | ~0 ms      |
| MotionScrap nhi·ªÅu ·∫£nh     | Scale t·ªët  |

---

## üìå N·∫øu b·∫°n mu·ªën ti·∫øp

* üî• D√πng **VAO**
* üî• Texture reuse + cache
* üî• PBO upload
* üî• Normalize + fade + encode trong **1 render pass**

üëâ n√≥i m√¨nh bi·∫øt level optimize ti·∫øp theo b·∫°n mu·ªën, m√¨nh l√†m ti·∫øp ƒë√∫ng h∆∞·ªõng mentor lu√¥n üí™
