OK, m√¨nh s·∫Ω ƒë∆∞a **FULL CODE ‚Äì T·∫§T C·∫¢ FILE C·∫¶N T·∫†O M·ªöI / UPDATE** cho **C√ÅCH 1 (2-PASS GPU NORMALIZE)**, theo ƒë√∫ng y√™u c·∫ßu:

> ‚úÖ **Gi·ªëng CPU `FrameNormalizer` 100%**
> ‚úÖ **KH√îNG m√©o v·ªõi frame n·∫±m ngang**
> ‚úÖ **Rotate ‚Üí t·∫°o texture m·ªõi ‚Üí Scale ‚Üí Center-crop**
> ‚úÖ **Kh√¥ng hack texcoord, kh√¥ng suy ƒëo√°n**
> ‚úÖ **·ªîn ƒë·ªãnh cho production**

M√¨nh s·∫Ω tr√¨nh b√†y theo th·ª© t·ª± **b·∫°n c√≥ th·ªÉ copy-paste t·ª´ng file**.

---

# 0Ô∏è‚É£ C·∫§U TR√öC FILE (G·ª¢I √ù)

```
gl/
 ‚îú‚îÄ GlProgram.kt          (UPDATE nh·ªè)
 ‚îú‚îÄ Texture2D.kt          (UPDATE nh·ªè)
 ‚îú‚îÄ FullscreenQuad.kt     (NEW)
 ‚îú‚îÄ GpuFrameNormalizer2Pass.kt  (NEW)
 ‚îú‚îÄ shaders/
 ‚îÇ    ‚îú‚îÄ fullscreen.vert
 ‚îÇ    ‚îú‚îÄ rotate.frag
 ‚îÇ    ‚îî‚îÄ scale_crop.frag
```

---

# 1Ô∏è‚É£ `Texture2D.kt` (UPDATE ‚Äì h·ªó tr·ª£ wrap textureId)

```kotlin
class Texture2D : AutoCloseable {

    val id: Int
    private val owns: Boolean
    private var released = false

    constructor(bitmap: Bitmap) {
        owns = true
        val tex = IntArray(1)
        GLES20.glGenTextures(1, tex, 0)
        id = tex[0]

        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, id)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)

        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0)
    }

    constructor(textureId: Int) {
        id = textureId
        owns = false
    }

    fun bind(unit: Int) {
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + unit)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, id)
    }

    override fun close() {
        if (released) return
        released = true
        if (owns) {
            GLES20.glDeleteTextures(1, intArrayOf(id), 0)
        }
    }
}
```

---

# 2Ô∏è‚É£ `GlProgram.kt` (UPDATE ‚Äì check compile/link)

```kotlin
class GlProgram(
    vertexSrc: String,
    fragmentSrc: String
) : AutoCloseable {

    val programId: Int
    private var released = false

    init {
        val vs = compile(GLES20.GL_VERTEX_SHADER, vertexSrc)
        val fs = compile(GLES20.GL_FRAGMENT_SHADER, fragmentSrc)

        programId = GLES20.glCreateProgram()
        GLES20.glAttachShader(programId, vs)
        GLES20.glAttachShader(programId, fs)
        GLES20.glLinkProgram(programId)

        val link = IntArray(1)
        GLES20.glGetProgramiv(programId, GLES20.GL_LINK_STATUS, link, 0)
        require(link[0] == GLES20.GL_TRUE) {
            GLES20.glGetProgramInfoLog(programId)
        }
    }

    private fun compile(type: Int, src: String): Int {
        val s = GLES20.glCreateShader(type)
        GLES20.glShaderSource(s, src)
        GLES20.glCompileShader(s)

        val ok = IntArray(1)
        GLES20.glGetShaderiv(s, GLES20.GL_COMPILE_STATUS, ok, 0)
        require(ok[0] == GLES20.GL_TRUE) {
            GLES20.glGetShaderInfoLog(s)
        }
        return s
    }

    fun use() {
        GLES20.glUseProgram(programId)
    }

    override fun close() {
        if (released) return
        released = true
        GLES20.glDeleteProgram(programId)
    }
}
```

---

# 3Ô∏è‚É£ `FullscreenQuad.kt` (NEW)

```kotlin
object FullscreenQuad {

    val data = floatArrayOf(
        -1f, -1f, 0f, 1f,
         1f, -1f, 1f, 1f,
        -1f,  1f, 0f, 0f,
         1f,  1f, 1f, 0f
    )

    val buffer: FloatBuffer =
        ByteBuffer.allocateDirect(data.size * 4)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer()
            .apply {
                put(data)
                position(0)
            }

    fun draw(program: GlProgram, texId: Int) {
        val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
        val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")
        val uTex = GLES20.glGetUniformLocation(program.programId, "uTexture")

        buffer.position(0)
        GLES20.glEnableVertexAttribArray(aPos)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, buffer)

        buffer.position(2)
        GLES20.glEnableVertexAttribArray(aTex)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, buffer)

        GLES20.glActiveTexture(GLES20.GL_TEXTURE0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texId)
        GLES20.glUniform1i(uTex, 0)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)
    }
}
```

---

# 4Ô∏è‚É£ Shader files (NEW)

## `fullscreen.vert`

```glsl
attribute vec4 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main() {
    gl_Position = aPosition;
    vTexCoord = aTexCoord;
}
```

---

## `rotate.frag` (PASS 1)

```glsl
precision mediump float;
uniform sampler2D uTexture;
uniform int uRotation;
varying vec2 vTexCoord;

vec2 rotateTex(vec2 tc) {
    if (uRotation == 90)  return vec2(tc.y, 1.0 - tc.x);
    if (uRotation == 180) return vec2(1.0 - tc.x, 1.0 - tc.y);
    if (uRotation == 270) return vec2(1.0 - tc.y, tc.x);
    return tc;
}

void main() {
    gl_FragColor = texture2D(uTexture, rotateTex(vTexCoord));
}
```

---

## `scale_crop.frag` (PASS 2)

```glsl
precision mediump float;
uniform sampler2D uTexture;
uniform vec2 uScale;
uniform vec2 uOffset;
varying vec2 vTexCoord;

void main() {
    vec2 tc = vTexCoord * uScale + uOffset;
    gl_FragColor = texture2D(uTexture, tc);
}
```

---

# 5Ô∏è‚É£ `GpuFrameNormalizer2Pass.kt` (NEW ‚Äì CORE)

```kotlin
class GpuFrameNormalizer2Pass(
    private val targetW: Int,
    private val targetH: Int
) {

    private val rotateProgram = GlProgram(
        Shaders.FULLSCREEN_VERTEX,
        Shaders.ROTATE_FRAGMENT
    )

    private val scaleProgram = GlProgram(
        Shaders.FULLSCREEN_VERTEX,
        Shaders.SCALE_CROP_FRAGMENT
    )

    fun normalize(src: Bitmap, rotation: Int): Int {

        val srcTex = Texture2D(src)

        // ===== PASS 1: ROTATE =====
        val rotW = if (rotation % 180 == 0) src.width else src.height
        val rotH = if (rotation % 180 == 0) src.height else src.width

        val rotTex = createEmptyTexture(rotW, rotH)
        val rotFbo = createFbo(rotTex)

        GLES20.glViewport(0, 0, rotW, rotH)
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, rotFbo)

        rotateProgram.use()
        GLES20.glUniform1i(
            GLES20.glGetUniformLocation(rotateProgram.programId, "uRotation"),
            ((rotation % 360) + 360) % 360
        )
        FullscreenQuad.draw(rotateProgram, srcTex.id)

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)

        // ===== PASS 2: SCALE + CENTER CROP =====
        val scale = maxOf(
            targetW.toFloat() / rotW,
            targetH.toFloat() / rotH
        )

        val scaledW = rotW * scale
        val scaledH = rotH * scale

        val uScaleX = scaledW / targetW
        val uScaleY = scaledH / targetH

        val uOffsetX = (uScaleX - 1f) / 2f
        val uOffsetY = (uScaleY - 1f) / 2f

        val outTex = createEmptyTexture(targetW, targetH)
        val outFbo = createFbo(outTex)

        GLES20.glViewport(0, 0, targetW, targetH)
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, outFbo)

        scaleProgram.use()
        GLES20.glUniform2f(
            GLES20.glGetUniformLocation(scaleProgram.programId, "uScale"),
            uScaleX, uScaleY
        )
        GLES20.glUniform2f(
            GLES20.glGetUniformLocation(scaleProgram.programId, "uOffset"),
            uOffsetX, uOffsetY
        )

        FullscreenQuad.draw(scaleProgram, rotTex)

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)

        // cleanup
        srcTex.close()
        GLES20.glDeleteTextures(1, intArrayOf(rotTex), 0)
        GLES20.glDeleteFramebuffers(1, intArrayOf(rotFbo), 0)

        return outTex
    }

    private fun createEmptyTexture(w: Int, h: Int): Int {
        val t = IntArray(1)
        GLES20.glGenTextures(1, t, 0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, t[0])
        GLES20.glTexImage2D(
            GLES20.GL_TEXTURE_2D, 0,
            GLES20.GL_RGBA,
            w, h, 0,
            GLES20.GL_RGBA,
            GLES20.GL_UNSIGNED_BYTE,
            null
        )
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)
        return t[0]
    }

    private fun createFbo(tex: Int): Int {
        val f = IntArray(1)
        GLES20.glGenFramebuffers(1, f, 0)
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, f[0])
        GLES20.glFramebufferTexture2D(
            GLES20.GL_FRAMEBUFFER,
            GLES20.GL_COLOR_ATTACHMENT0,
            GLES20.GL_TEXTURE_2D,
            tex, 0
        )
        check(GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER)
                == GLES20.GL_FRAMEBUFFER_COMPLETE)
        return f[0]
    }
}
```

---

# 6Ô∏è‚É£ S·ª¨ D·ª§NG TRONG `FadeTransitionRenderer`

```kotlin
eglSurface.makeCurrent()

val normalizer = GpuFrameNormalizer2Pass(width, height)

val texPrev = normalizer.normalize(prevBitmap, rotation)
val texNext = normalizer.normalize(nextBitmap, rotation)

val t1 = Texture2D(texPrev)
val t2 = Texture2D(texNext)
glRenderer.setTextures(t1, t2)
```

---

# ‚úÖ K·∫æT LU·∫¨N CU·ªêI (DEV 20 NƒÇM)

* CPU **kh√¥ng m√©o** v√¨ rotate t·∫°o d·ªØ li·ªáu m·ªõi
* GPU **ch·ªâ an to√†n** khi l√†m ƒëi·ªÅu t∆∞∆°ng ƒë∆∞∆°ng
* 2-pass FBO l√†:

  * ƒë√∫ng
  * d·ªÖ maintain
  * debug ƒë∆∞·ª£c
  * production-safe

N·∫øu b·∫°n mu·ªën b∆∞·ªõc ti·∫øp:

* üî• t·ªëi ∆∞u FBO reuse
* üöÄ g·ªôp 2 pass
* üß™ pixel diff CPU vs GPU

c·ª© n√≥i ti·∫øp.
