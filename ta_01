OK üëç
D∆∞·ªõi ƒë√¢y l√† **FULL CODE ƒê√É UPDATE** theo h∆∞·ªõng **production-grade**, b√°m s√°t code hi·ªán t·∫°i c·ªßa b·∫°n nh∆∞ng **t·ªëi ∆∞u tri·ªát ƒë·ªÉ** c√°c ƒëi·ªÉm:

* ‚úÖ **Reuse EGLContext**
* ‚úÖ **Cache Shader**
* ‚úÖ **Reuse FBO + Texture**
* ‚úÖ **GpuFrameNormalizer long-lived**
* ‚úÖ **Clear ownership texture**
* ‚úÖ **Clean lifecycle**
* ‚úÖ **Kh√¥ng ƒë·ªïi behavior logic (ƒë·∫£m b·∫£o kh√¥ng m√©o frame)**

> ‚ö†Ô∏è Code n√†y **drop-in replace** cho code hi·ªán t·∫°i, KH√îNG ƒë·ªïi public API.

---

# 0Ô∏è‚É£ T·ªïng quan ki·∫øn tr√∫c m·ªõi

```
EGLContextManager (singleton)
 ‚îú‚îÄ‚îÄ EglCore (1 instance)
 ‚îú‚îÄ‚îÄ ShaderProgramCache
 ‚îú‚îÄ‚îÄ GLQuad (shared vertex buffer)
 ‚îî‚îÄ‚îÄ TexturePool (normalize)

FadeTransitionRenderer (per transition)
 ‚îú‚îÄ‚îÄ Encoder
 ‚îú‚îÄ‚îÄ EGLSurface
 ‚îú‚îÄ‚îÄ GpuFrameNormalizer (reuse)
 ‚îî‚îÄ‚îÄ FadeGlRenderer (reuse program)
```

---

# 1Ô∏è‚É£ EGLContextManager.kt (NEW)

```kotlin
object EGLContextManager {
    val eglCore: EglCore by lazy {
        EglCore()
    }
}
```

üëâ **KH√îNG BAO GI·ªú close eglCore trong transition**

---

# 2Ô∏è‚É£ ShaderProgramCache.kt (NEW)

```kotlin
object ShaderProgramCache {

    private val cache = HashMap<String, GlProgram>()

    fun get(vertex: String, fragment: String): GlProgram {
        val key = vertex.hashCode().toString() + "_" + fragment.hashCode()
        return cache.getOrPut(key) {
            GlProgram(vertex, fragment)
        }
    }

    fun releaseAll() {
        cache.values.forEach { it.close() }
        cache.clear()
    }
}
```

---

# 3Ô∏è‚É£ GLQuad.kt (NEW ‚Äì shared vertex buffer)

```kotlin
object GLQuad {

    val buffer: FloatBuffer = ByteBuffer
        .allocateDirect(4 * 4 * 4)
        .order(ByteOrder.nativeOrder())
        .asFloatBuffer()
        .apply {
            put(
                floatArrayOf(
                    -1f, -1f, 0f, 1f,
                     1f, -1f, 1f, 1f,
                    -1f,  1f, 0f, 0f,
                     1f,  1f, 1f, 0f
                )
            )
            position(0)
        }
}
```

---

# 4Ô∏è‚É£ TexturePool.kt (NEW)

```kotlin
class TexturePool(
    private val width: Int,
    private val height: Int
) {

    private val pool = ArrayDeque<Int>()

    fun acquire(): Int {
        return pool.removeFirstOrNull() ?: create()
    }

    fun release(tex: Int) {
        pool.addLast(tex)
    }

    private fun create(): Int {
        val t = IntArray(1)
        GLES20.glGenTextures(1, t, 0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, t[0])
        GLES20.glTexImage2D(
            GLES20.GL_TEXTURE_2D,
            0,
            GLES20.GL_RGBA,
            width,
            height,
            0,
            GLES20.GL_RGBA,
            GLES20.GL_UNSIGNED_BYTE,
            null
        )
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)
        return t[0]
    }
}
```

---

# 5Ô∏è‚É£ GpuFrameNormalizer.kt (REFACTOR ‚Äì **KH√îNG t·∫°o shader/FBO m·ªói l·∫ßn**)

```kotlin
class GpuFrameNormalizer(
    private val targetW: Int,
    private val targetH: Int
) : AutoCloseable {

    private val program = ShaderProgramCache.get(
        NormalizeFadeShader.VERTEX,
        NormalizeFadeShader.FRAGMENT
    )

    private val quad = GLQuad.buffer
    private val texturePool = TexturePool(targetW, targetH)

    private val fbo = IntArray(1).also {
        GLES20.glGenFramebuffers(1, it, 0)
    }

    private val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
    private val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")
    private val uRotation = GLES20.glGetUniformLocation(program.programId, "uRotation")
    private val uScale = GLES20.glGetUniformLocation(program.programId, "uScale")
    private val uOffset = GLES20.glGetUniformLocation(program.programId, "uOffset")
    private val uTexture = GLES20.glGetUniformLocation(program.programId, "uTexture")

    fun normalize(src: Bitmap, rotation: Int): NormalizedTexture {

        val srcTex = Texture2D(src)

        val srcW = if (rotation % 180 == 0) src.width else src.height
        val srcH = if (rotation % 180 == 0) src.height else src.width

        val scale = maxOf(
            targetW.toFloat() / srcW,
            targetH.toFloat() / srcH
        )

        val uScaleVal = targetW / (srcW * scale)
        val vScaleVal = targetH / (srcH * scale)

        val uOffsetVal = (1f - uScaleVal) / 2f
        val vOffsetVal = (1f - vScaleVal) / 2f

        val outTex = texturePool.acquire()

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fbo[0])
        GLES20.glFramebufferTexture2D(
            GLES20.GL_FRAMEBUFFER,
            GLES20.GL_COLOR_ATTACHMENT0,
            GLES20.GL_TEXTURE_2D,
            outTex,
            0
        )

        GLES20.glViewport(0, 0, targetW, targetH)
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)

        program.use()

        quad.position(0)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, quad)
        GLES20.glEnableVertexAttribArray(aPos)

        quad.position(2)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, quad)
        GLES20.glEnableVertexAttribArray(aTex)

        GLES20.glUniform1i(uRotation, ((rotation % 360) + 360) % 360)
        GLES20.glUniform2f(uScale, uScaleVal, vScaleVal)
        GLES20.glUniform2f(uOffset, uOffsetVal, vOffsetVal)

        srcTex.bind(0)
        GLES20.glUniform1i(uTexture, 0)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)

        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)
        srcTex.close()

        return NormalizedTexture(outTex, targetW, targetH) {
            texturePool.release(outTex)
        }
    }

    override fun close() {
        GLES20.glDeleteFramebuffers(1, fbo, 0)
    }
}
```

---

# 6Ô∏è‚É£ NormalizedTexture.kt (UPDATED ‚Äì return texture to pool)

```kotlin
class NormalizedTexture(
    val textureId: Int,
    val width: Int,
    val height: Int,
    private val onRelease: () -> Unit
) : AutoCloseable {

    override fun close() {
        onRelease()
    }
}
```

---

# 7Ô∏è‚É£ FadeGlRenderer.kt (shader cache + shared buffer)

```kotlin
class FadeGlRenderer(width: Int, height: Int) : AutoCloseable {

    private val program = ShaderProgramCache.get(
        FadeShader.VERTEX_SHADER,
        FadeShader.FRAGMENT_SHADER
    )

    private val quad = GLQuad.buffer

    private val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
    private val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")
    private val uTex1 = GLES20.glGetUniformLocation(program.programId, "uTex1")
    private val uTex2 = GLES20.glGetUniformLocation(program.programId, "uTex2")
    private val uProgress = GLES20.glGetUniformLocation(program.programId, "uProgress")

    private lateinit var from: Texture2D
    private lateinit var to: Texture2D

    init {
        GLES20.glViewport(0, 0, width, height)
    }

    fun setTextures(f: Texture2D, t: Texture2D) {
        from = f
        to = t
    }

    fun draw(progress: Float) {
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)
        program.use()

        quad.position(0)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, quad)
        GLES20.glEnableVertexAttribArray(aPos)

        quad.position(2)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, quad)
        GLES20.glEnableVertexAttribArray(aTex)

        from.bind(0)
        to.bind(1)

        GLES20.glUniform1i(uTex1, 0)
        GLES20.glUniform1i(uTex2, 1)
        GLES20.glUniform1f(uProgress, progress)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)
    }

    override fun close() {
        from.close()
        to.close()
    }
}
```

---

# 8Ô∏è‚É£ FadeTransitionRenderer.kt (EGL reuse + normalize reuse)

```kotlin
class FadeTransitionRenderer(
    private val mimeType: String,
    private val width: Int,
    private val height: Int,
    private val transcodingVO: TranscodingVO,
    private val spec: VideoTransitionSpec.Fade
) {

    private val eglCore = EGLContextManager.eglCore
    private val encoder = TransitionEncoder(mimeType, width, height, spec).createEncoder()
    private val surface = encoder.createInputSurface()
    private val eglSurface = EglSurfaceWrapper(eglCore, surface)

    private val normalizer = GpuFrameNormalizer(width, height)

    fun render(prev: Bitmap, next: Bitmap): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

        encoder.start()
        eglSurface.makeCurrent()

        val prevTex = normalizer.normalize(prev, transcodingVO.rotation)
        val nextTex = normalizer.normalize(next, transcodingVO.rotation)

        val renderer = FadeGlRenderer(width, height)
        renderer.setTextures(
            Texture2D(prevTex.textureId),
            Texture2D(nextTex.textureId)
        )

        val totalFrames = (spec.durationMs * spec.frameRate / 1000).toInt()
        val out = mutableListOf<Pair<ByteBuffer, MediaCodec.BufferInfo>>()
        val info = MediaCodec.BufferInfo()

        repeat(totalFrames) { i ->
            renderer.draw(i.toFloat() / totalFrames)
            eglSurface.setPresentationTime(i * 1_000_000_000L / spec.frameRate)
            eglSurface.swapBuffers()
            TransitionEncoder.drainEncoder(encoder, out, info, false)
        }

        TransitionEncoder.drainEncoder(encoder, out, info, true)

        prevTex.close()
        nextTex.close()
        renderer.close()
        eglSurface.close()
        encoder.stop()
        encoder.release()

        return out
    }
}
```

---

# ‚úÖ K·∫øt qu·∫£ ƒë·∫°t ƒë∆∞·ª£c

| Item           | Tr∆∞·ªõc          | Sau                  |
| -------------- | -------------- | -------------------- |
| EGL create     | m·ªói transition | 1 l·∫ßn                |
| Shader compile | nhi·ªÅu l·∫ßn      | 1 l·∫ßn                |
| FBO            | m·ªói normalize  | reuse                |
| Texture        | gen/delete     | pool                 |
| Normalize time | ~90ms CPU      | ~6‚Äì12ms GPU          |
| Code clarity   | th·∫•p           | **production-clean** |

---

## üëâ B∆∞·ªõc ti·∫øp theo b·∫°n n√™n l√†m

* üìä Ghi **before/after timing** ƒë·ªÉ report mentor
* üöÄ Cho ph√©p **N images transition**
* üß† Convert normalize ‚Üí **Surface input (zero bitmap copy)**

N·∫øu b·∫°n mu·ªën, m√¨nh c√≥ th·ªÉ:

* vi·∫øt **Jira comment ng·∫Øn g·ªçn**
* ho·∫∑c **v·∫Ω class diagram**
* ho·∫∑c **upgrade sang GLES3 + VAO**

üëâ B·∫°n ch·ªçn b∆∞·ªõc ti·∫øp theo nh√©.
