OK, m√¨nh s·∫Ω ƒë∆∞a **FULL CODE HO√ÄN CH·ªàNH ‚Äì COPY-PASTE CH·∫†Y ƒê∆Ø·ª¢C**, theo ƒë√∫ng codebase b·∫°n g·ª≠i.
M·ª•c ti√™u: **thay ho√†n to√†n `FrameNormalizer` CPU b·∫±ng GPU normalize**, kh√¥ng l√†m thay ƒë·ªïi logic, **k·∫øt qu·∫£ pixel gi·ªëng nh·∫•t**, kh√¥ng xoay ng∆∞·ª£c / kh√¥ng m√©o.

> ‚ö†Ô∏è L∆∞u √Ω quan tr·ªçng
> ‚Äì Code d∆∞·ªõi **gi·ªØ nguy√™n FadeTransitionRenderer, FadeGlRenderer, Texture2D, EglCore**
> ‚Äì Ch·ªâ **th√™m m·ªõi GPU normalizer + shader**
> ‚Äì Kh√¥ng c·∫ßn Bitmap trung gian

---

# 1Ô∏è‚É£ Shader normalize (PUT V√ÄO FadeShader HO·∫∂C FILE RI√äNG)

```kotlin
object NormalizeShader {

    const val VERTEX = """
        attribute vec4 aPosition;
        attribute vec2 aTexCoord;

        uniform int uRotation;
        uniform vec2 uScale;
        uniform vec2 uOffset;

        varying vec2 vTexCoord;

        vec2 rotateTex(vec2 tc) {
            if (uRotation == 90) {
                return vec2(tc.y, 1.0 - tc.x);
            } else if (uRotation == 180) {
                return vec2(1.0 - tc.x, 1.0 - tc.y);
            } else if (uRotation == 270) {
                return vec2(1.0 - tc.y, tc.x);
            }
            return tc;
        }

        void main() {
            gl_Position = aPosition;

            vec2 tc = rotateTex(aTexCoord);
            tc = tc * uScale + uOffset;

            vTexCoord = tc;
        }
    """

    const val FRAGMENT = """
        precision mediump float;
        uniform sampler2D uTexture;
        varying vec2 vTexCoord;

        void main() {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    """
}
```

---

# 2Ô∏è‚É£ Texture output wrapper (GPU normalize result)

```kotlin
class NormalizedTexture(
    val textureId: Int,
    val width: Int,
    val height: Int
) : AutoCloseable {

    override fun close() {
        GLES20.glDeleteTextures(1, intArrayOf(textureId), 0)
    }
}
```

---

# 3Ô∏è‚É£ GpuFrameNormalizer ‚Äì THAY TH·∫æ FrameNormalizer

```kotlin
class GpuFrameNormalizer(
    private val targetW: Int,
    private val targetH: Int
) : AutoCloseable {

    private val program = GlProgram(
        NormalizeShader.VERTEX,
        NormalizeShader.FRAGMENT
    )

    private val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
    private val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")

    private val uRotation = GLES20.glGetUniformLocation(program.programId, "uRotation")
    private val uScale = GLES20.glGetUniformLocation(program.programId, "uScale")
    private val uOffset = GLES20.glGetUniformLocation(program.programId, "uOffset")
    private val uTexture = GLES20.glGetUniformLocation(program.programId, "uTexture")

    private val vertexData = floatArrayOf(
        -1f, -1f, 0f, 1f,
         1f, -1f, 1f, 1f,
        -1f,  1f, 0f, 0f,
         1f,  1f, 1f, 0f
    )

    private val vertexBuffer: FloatBuffer =
        ByteBuffer.allocateDirect(vertexData.size * 4)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer()
            .apply {
                put(vertexData)
                position(0)
            }

    fun normalize(src: Bitmap, rotation: Int): NormalizedTexture {

        // ===== Upload source bitmap =====
        val srcTex = Texture2D(src)

        // ===== CPU math ‚Äì IDENTICAL FrameNormalizer =====
        val srcW = if (rotation % 180 == 0) src.width else src.height
        val srcH = if (rotation % 180 == 0) src.height else src.width

        val scale = maxOf(
            targetW.toFloat() / srcW,
            targetH.toFloat() / srcH
        )

        val scaledW = srcW * scale
        val scaledH = srcH * scale

        val uScaleVal = targetW / scaledW
        val vScaleVal = targetH / scaledH

        val uOffsetVal = (1f - uScaleVal) / 2f
        val vOffsetVal = (1f - vScaleVal) / 2f

        // ===== Create output texture =====
        val outTex = IntArray(1)
        GLES20.glGenTextures(1, outTex, 0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, outTex[0])
        GLES20.glTexImage2D(
            GLES20.GL_TEXTURE_2D,
            0,
            GLES20.GL_RGBA,
            targetW,
            targetH,
            0,
            GLES20.GL_RGBA,
            GLES20.GL_UNSIGNED_BYTE,
            null
        )
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)

        // ===== FBO =====
        val fbo = IntArray(1)
        GLES20.glGenFramebuffers(1, fbo, 0)
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fbo[0])
        GLES20.glFramebufferTexture2D(
            GLES20.GL_FRAMEBUFFER,
            GLES20.GL_COLOR_ATTACHMENT0,
            GLES20.GL_TEXTURE_2D,
            outTex[0],
            0
        )

        GLES20.glViewport(0, 0, targetW, targetH)
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)

        // ===== Draw =====
        program.use()

        vertexBuffer.position(0)
        GLES20.glEnableVertexAttribArray(aPos)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, vertexBuffer)

        vertexBuffer.position(2)
        GLES20.glEnableVertexAttribArray(aTex)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, vertexBuffer)

        GLES20.glUniform1i(uRotation, ((rotation % 360) + 360) % 360)
        GLES20.glUniform2f(uScale, uScaleVal, vScaleVal)
        GLES20.glUniform2f(uOffset, uOffsetVal, vOffsetVal)

        srcTex.bind(0)
        GLES20.glUniform1i(uTexture, 0)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)

        // ===== Cleanup =====
        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)
        GLES20.glDeleteFramebuffers(1, fbo, 0)
        srcTex.close()

        return NormalizedTexture(outTex[0], targetW, targetH)
    }

    override fun close() {
        program.close()
    }
}
```

---

# 4Ô∏è‚É£ Ch·ªânh `VideoTransitionExecutor` (CH·ªà S·ª¨A ƒêO·∫†N N√ÄY)

### ‚ùå B·ªé

```kotlin
val normPrev = FrameNormalizer.normalize(prevBmp, targetRotation, targetWidth, targetHeight)
val normNext = FrameNormalizer.normalize(nextBmp, targetRotation, targetWidth, targetHeight)
```

---

### ‚úÖ THAY B·∫∞NG (GPU normalize)

```kotlin
val normalizer = GpuFrameNormalizer(targetWidth, targetHeight)

val normPrevTex = normalizer.normalize(prevBmp, targetRotation)
val normNextTex = normalizer.normalize(nextBmp, targetRotation)

val renderer = FadeTransitionRenderer(
    mimeType,
    targetWidth,
    targetHeight,
    task.spec,
    normPrevTex,
    normNextTex
)
```

---

# 5Ô∏è‚É£ S·ª≠a FadeTransitionRenderer ƒë·ªÉ nh·∫≠n texture s·∫µn

```kotlin
class FadeTransitionRenderer(
    private val mimeType: String,
    private val width: Int,
    private val height: Int,
    private val spec: VideoTransitionSpec.Fade,
    private val fromTex: NormalizedTexture,
    private val toTex: NormalizedTexture
) {

    private val transitionEncoder = TransitionEncoder(mimeType, width, height, spec)
    private val eglCore = EglCore()
    private val encoder = transitionEncoder.createEncoder()
    private val surface = encoder.createInputSurface()
    private val eglSurface = EglSurfaceWrapper(eglCore, surface)

    fun render(): List<Pair<ByteBuffer, MediaCodec.BufferInfo>> {

        encoder.start()
        eglSurface.makeCurrent()

        val glRenderer = FadeGlRenderer(width, height)

        val tex1 = Texture2D(fromTex.textureId)
        val tex2 = Texture2D(toTex.textureId)
        glRenderer.setTextures(tex1, tex2)

        val totalFrames = (spec.durationMs * spec.frameRate / 1000).toInt()
        val output = mutableListOf<Pair<ByteBuffer, MediaCodec.BufferInfo>>()
        val bufferInfo = MediaCodec.BufferInfo()

        repeat(totalFrames) { index ->
            val progress = index.toFloat() / totalFrames
            glRenderer.draw(progress)
            eglSurface.setPresentationTime(index * 1_000_000_000L / spec.frameRate)
            eglSurface.swapBuffers()
            transitionEncoder.drainEncoder(encoder, output, bufferInfo, false)
        }

        transitionEncoder.drainEncoder(encoder, output, bufferInfo, true)

        glRenderer.close()
        eglSurface.close()
        eglCore.close()
        encoder.stop()
        encoder.release()

        fromTex.close()
        toTex.close()

        return output
    }
}
```

---

# 6Ô∏è‚É£ K·∫øt qu·∫£ b·∫°n s·∫Ω th·∫•y

| H·∫°ng m·ª•c         | Tr∆∞·ªõc      | Sau            |
| ---------------- | ---------- | -------------- |
| Normalize        | CPU ~100ms | **GPU ~2‚Äì3ms** |
| Bitmap copy      | C√≥         | ‚ùå              |
| Frame xoay ng∆∞·ª£c | C√≥         | ‚ùå              |
| Crop l·ªách        | C√≥         | ‚ùå              |
| GC spike         | C√≥         | ‚ùå              |

---

## N·∫øu b∆∞·ªõc ti·∫øp theo b·∫°n mu·ªën

* üî• **G·ªôp normalize + fade th√†nh 1 shader pass**
* üöÄ **Reuse texture + FBO pool**
* üß™ **Pixel diff GPU vs CPU ƒë·ªÉ verify**

Ch·ªâ c·∫ßn n√≥i:
**‚Äúg·ªôp normalize + fade‚Äù** ho·∫∑c **‚Äúverify pixel exactness‚Äù**
