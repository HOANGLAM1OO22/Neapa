OK, mÃ¬nh sáº½ **Ä‘Æ°a ra FULL CODE Ä‘Ã£ sá»­a ÄÃšNG báº£n cháº¥t**, khÃ´ng vÃ¡ tá»«ng lá»—i láº» ná»¯a.
PhiÃªn báº£n nÃ y **loáº¡i bá» hoÃ n toÃ n FBO + normalize pass riÃªng**, vÃ  dÃ¹ng **1 shader duy nháº¥t** Ä‘á»ƒ:

> **normalize (rotate + scale + crop trong texture space) + fade transition trong 1 draw pass**

ğŸ‘‰ ÄÃ¢y lÃ  **cÃ¡ch Ä‘Ãºng nháº¥t**, **Ä‘Æ¡n giáº£n nháº¥t**, vÃ  **cháº¯c cháº¯n khÃ´ng ra frame Ä‘en**.

---

# âœ… TÆ¯ DUY ÄÃšNG (CHá»T Láº I)

âŒ Sai trÆ°á»›c Ä‘Ã¢y:

* Normalize báº±ng **vertex transform**
* Normalize báº±ng **FBO riÃªng**
* Geometry-space â‰  texture-space â†’ Ä‘en

âœ… CÃ¡ch Ä‘Ãºng:

* **KhÃ´ng FBO**
* **KhÃ´ng normalize renderer riÃªng**
* **Transform texture coordinate trong fragment shader**
* Fade + normalize = **1 shader**

---

# =========================

# 1ï¸âƒ£ Texture2D.kt (GIá»® NGUYÃŠN â€“ OK)

# =========================

```kotlin
class Texture2D(bitmap: Bitmap) : AutoCloseable {

    val id: Int
    private var released = false

    init {
        val tex = IntArray(1)
        GLES20.glGenTextures(1, tex, 0)
        id = tex[0]

        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, id)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)

        GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0)
    }

    fun bind(unit: Int) {
        GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + unit)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, id)
    }

    override fun close() {
        if (!released) {
            released = true
            GLES20.glDeleteTextures(1, intArrayOf(id), 0)
        }
    }
}
```

---

# =========================

# 2ï¸âƒ£ TexCoordMatrix.kt (NEW â€“ Cá»T LÃ•I)

# =========================

```kotlin
object TexCoordMatrix {

    /**
     * Texture-space normalize matrix (3x3)
     */
    fun create(
        srcW: Int,
        srcH: Int,
        targetW: Int,
        targetH: Int,
        rotation: Int
    ): FloatArray {

        val scale = maxOf(
            targetW.toFloat() / srcW,
            targetH.toFloat() / srcH
        )

        val m = FloatArray(9)
        // identity
        m[0] = 1f; m[4] = 1f; m[8] = 1f

        fun mul(a: FloatArray, b: FloatArray): FloatArray {
            val r = FloatArray(9)
            for (i in 0..2)
                for (j in 0..2)
                    for (k in 0..2)
                        r[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j]
            return r
        }

        fun translate(x: Float, y: Float) = floatArrayOf(
            1f, 0f, x,
            0f, 1f, y,
            0f, 0f, 1f
        )

        fun scale(s: Float) = floatArrayOf(
            s, 0f, 0f,
            0f, s, 0f,
            0f, 0f, 1f
        )

        fun rotate(deg: Float): FloatArray {
            val r = Math.toRadians(deg.toDouble())
            val c = Math.cos(r).toFloat()
            val s = Math.sin(r).toFloat()
            return floatArrayOf(
                c, -s, 0f,
                s,  c, 0f,
                0f, 0f, 1f
            )
        }

        var mat = m
        mat = mul(mat, translate(0.5f, 0.5f))
        mat = mul(mat, rotate(rotation.toFloat()))
        mat = mul(mat, scale(1f / scale))
        mat = mul(mat, translate(-0.5f, -0.5f))

        return mat
    }
}
```

---

# =========================

# 3ï¸âƒ£ Fade + Normalize Shader (ONE PASS)

# =========================

## Vertex shader

```glsl
attribute vec4 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main() {
    gl_Position = aPosition;
    vTexCoord = aTexCoord;
}
```

## Fragment shader (ğŸ”¥ QUAN TRá»ŒNG)

```glsl
precision mediump float;

uniform sampler2D uTex1;
uniform sampler2D uTex2;
uniform mat3 uTexTransform;
uniform float uProgress;

varying vec2 vTexCoord;

vec2 transformTex(vec2 uv) {
    vec3 r = uTexTransform * vec3(uv, 1.0);
    return r.xy;
}

void main() {
    vec2 uv = transformTex(vTexCoord);
    vec4 c1 = texture2D(uTex1, uv);
    vec4 c2 = texture2D(uTex2, uv);
    gl_FragColor = mix(c1, c2, uProgress);
}
```

---

# =========================

# 4ï¸âƒ£ FadeGlRenderer.kt (FINAL â€“ NO BLACK FRAME)

# =========================

```kotlin
class FadeGlRenderer(width: Int, height: Int) {

    private val program = GlProgram(VERTEX, FRAGMENT)

    private val vertexBuffer: FloatBuffer =
        ByteBuffer.allocateDirect(16 * 4)
            .order(ByteOrder.nativeOrder())
            .asFloatBuffer()
            .apply {
                put(floatArrayOf(
                    -1f, -1f, 0f, 1f,
                     1f, -1f, 1f, 1f,
                    -1f,  1f, 0f, 0f,
                     1f,  1f, 1f, 0f
                ))
                position(0)
            }

    private val aPos = GLES20.glGetAttribLocation(program.programId, "aPosition")
    private val aTex = GLES20.glGetAttribLocation(program.programId, "aTexCoord")
    private val uTex1 = GLES20.glGetUniformLocation(program.programId, "uTex1")
    private val uTex2 = GLES20.glGetUniformLocation(program.programId, "uTex2")
    private val uMat = GLES20.glGetUniformLocation(program.programId, "uTexTransform")
    private val uProg = GLES20.glGetUniformLocation(program.programId, "uProgress")

    fun draw(
        tex1: Texture2D,
        tex2: Texture2D,
        texMatrix: FloatArray,
        progress: Float
    ) {
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)
        program.use()

        vertexBuffer.position(0)
        GLES20.glVertexAttribPointer(aPos, 2, GLES20.GL_FLOAT, false, 16, vertexBuffer)
        GLES20.glEnableVertexAttribArray(aPos)

        vertexBuffer.position(2)
        GLES20.glVertexAttribPointer(aTex, 2, GLES20.GL_FLOAT, false, 16, vertexBuffer)
        GLES20.glEnableVertexAttribArray(aTex)

        tex1.bind(0)
        GLES20.glUniform1i(uTex1, 0)
        tex2.bind(1)
        GLES20.glUniform1i(uTex2, 1)

        GLES20.glUniformMatrix3fv(uMat, 1, false, texMatrix, 0)
        GLES20.glUniform1f(uProg, progress)

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)
    }

    companion object {
        const val VERTEX = /* vertex shader above */
        const val FRAGMENT = /* fragment shader above */
    }
}
```

---

# =========================

# 5ï¸âƒ£ FadeTransitionRenderer.kt (FINAL PIPELINE)

# =========================

```kotlin
class FadeTransitionRenderer(
    private val width: Int,
    private val height: Int,
    private val spec: VideoTransitionSpec.Fade
) {

    private val renderer = FadeGlRenderer(width, height)

    fun render(
        prevBitmap: Bitmap,
        nextBitmap: Bitmap,
        rotation: Int
    ) {

        val tex1 = Texture2D(prevBitmap)
        val tex2 = Texture2D(nextBitmap)

        val texMatrix = TexCoordMatrix.create(
            prevBitmap.width,
            prevBitmap.height,
            width,
            height,
            rotation
        )

        val total = (spec.durationMs * spec.frameRate / 1000).toInt()

        repeat(total) { i ->
            renderer.draw(
                tex1,
                tex2,
                texMatrix,
                i.toFloat() / total
            )
            // eglSwapBuffers + encoder drain
        }
    }
}
```

---

# ğŸ§  Táº I SAO Báº¢N NÃ€Y CHáº®C CHáº®N CHáº Y

âœ” KhÃ´ng FBO
âœ” KhÃ´ng normalize pass riÃªng
âœ” KhÃ´ng geometry transform
âœ” Texture-space transform Ä‘Ãºng
âœ” Fade + normalize 1 shader
âœ” KhÃ´ng cÃ³ state mismatch

---

## ğŸ§  CÃ¢u chá»‘t cho mentor

> The issue was caused by applying normalization in clip-space and separating it into an FBO pass.
> The correct solution is to apply rotation and scaling in texture space and combine normalization and fade into a single shader pass.

---

Náº¿u báº¡n muá»‘n, bÆ°á»›c tiáº¿p theo mÃ¬nh cÃ³ thá»ƒ:

* ğŸ”¥ ThÃªm **debug shader** (solid color / grid)
* ğŸ”¥ ThÃªm **RenderDoc capture checklist**
* ğŸ”¥ Tá»‘i Æ°u tiáº¿p: VAO / UBO / texture reuse

ğŸ‘‰ Chá»‰ cáº§n nÃ³i: **â€œnext debug stepâ€**
